# Nodejs

### 1.关于Node.js

> 1.Node.js是一个让 JavaScript 运行在服务器端的开发平台
>
> 2.Nodejs不是一种独立的语言,与PHP,JSP，Python,Perl,Ruby的"即是语言，也是平台"不同，Nodejs的使用JavaScript进行编程，运行在JavaScript引擎上(V8)
>
> 3.与PHP,JSP等相比，Nodejs跳过了Apache,Naginx,IIS等HTTP服务器，它自己不用建设在任何服务器软件之上,Nodejs的许多设计理念与经典架构(LAMP) 有着很大的不同，可以提供强大的伸缩能力

### 2.特点

> 单线程 | 非阻塞I/O | 事件驱动
>
> ---------------------------------------------------------------------------------------------------------------------------------------
>
> - 单线程
>
> 所以客户端请求的连接 都使用一个线程来处理
>
> Nodejs不是给每个连接区创建新的 线程,而是仅仅使用一个线程来处理
>
> 单线程带来的好处 减少内存的损耗 提高并发量 操作系统完全不在有线程创建和销毁的开销
>
> - 非阻塞I/O
>
> I: Input 输入
>
> O: Output 输出
>
> 在阻塞模式下，一个线程只能处理一项任务，想要提高吞吐率，必须通过多线程
>
> 而非阻塞模式下，一个线程 永远在执行某种永远在执行某种运输操作，这个线程的CPU 核心利用率永远是满载的
>
> - 事件驱动
>
>   客户端 请求建立连接，提交数据等行为，就会触发 相应的事件
>
>   在Node中，在一个时刻，只能执行 一个事件回调函数，但是在执行 一个事件回调函数的中途(比如又有新用户连接了) 可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为"事件环"机制
>
> Nodejs底层是C++(V8引擎也是C++写的).底层代码中,近半数都是用于事件队列,回调函数队列的构建，用事件驱动 来完成服务器的 任务调用是Nodejs中 真正底层核心逻辑
>
> - 三特点说明
>
>   - 单线程 是为了减少内存的开销，操作系统的内存换页(创建/销毁) 
>
>     但是如果某一个请求有I/O操作，单线程就会被阻塞了
>
>   - 非阻塞I/O 程序不会傻等I/O语句的执行结束，才继续后续代码的运行，而会直接运行后续代码.但是非阻塞就能完美的解决问题吗 比如 小A 的业务执行I/O过程中，有小C要求的请求，此时怎么办？
>
>     不管是新用户的请求还是老用户的请求，都将以事件的方式加入到事件环中，等待调用

### 3.Nodejs的优缺点，适合开发什么?

> * 优点
>   * 善于I/O,不善于 大量计算
>   * 处理高并发
>   * 服务器推送
> * 缺点
>   * 单线程的缺点: 单一线程 一旦崩溃整个服务全崩溃
> * 适用场景
>   * 聊天室
>   * 图文直播
>   * 考试系统
>   * 收集用户数据的表单
>   * 提供JSON的API

### 4.模块

> Nodejs将各种功能，都划分为了一个个mudule(模块)需要用什么模块就可以使用require('')来引入使用
>
> 在Nodejs中，不可能用一个js文件区写全部的业务，肯定要有MVC
>
> 他以模块位单位 划分所以功能，并且提供了一个完整的模块加载机制，我们可以将应用程序划分为各个不同的部分
>
> 每一个JavaScript文件都是一个模块；
>
> 而多个JavaScript文件可以使用require引入，使他们共同实现一个功能模块
>
> * 输出变量/函数
>
>   Nodejs中，JS文件中定义的变量，函数，都只在这个文件内部有效
>
>   其他文件中需要引入变量，函数时，必须使用`export对象`进行输出
>
>   使用者要用`require()`命令，引用执行这个JS文件
>
> * 输出一个类(构造函数)
>
>   可以用`module.exports = 构造函数名;`的方式 向外输出一个类
>
> * 模块关联关系
>
>   * 某一个JS文件中，有函数或变量:exports.变量 = 变量；
>   * 某一个JS文件中，有一个类：module.exports = 构造函数名；

### 5.npm

> 这是一个工具名字，npm的主要职责是 安装开发包和管理依赖项
>
> 安装开发包: 安装`npm install`命令；更新`npm ubdate`命令
>
> 管理依赖项:借助 package.json 文件l最简单生成 package.json 的方法就是 `npm init`

### 6.GET

> GET请求的参数在URL中
>
> 原生node中，要想得到get参数，需要借助与url模块来识别参数字符串
>
> 在Express中，不需要使用URL模块了，可以直接使用`req.query`对象得到GET参数

### 7.POST

> 原生Nodejs:
>
> ​					相比较GET请求，POST请求比较复杂。因为Nodejs认为,使用POST请求时,数据量比较多为了追求极致的效率,它将数据拆分成为了众多小的数据块(chunk)，然后通过特定的事件,将这些小数据块有序传递给回调函数
>
> Express框架:
>
> ​					POST请求的参数是隐藏传参(在请求体中) POST请求在Express中不能直接获得,必须使用`body-parser`模块,之后可通过`req.body`得到参数 如果表单中含有文件上传,那么还需要使用`formidable`参数

### 8.连接mysql

> * 1.导入模板 `var mysql = require('mysql');`
>
> * 2.连接数据库  
>
>   ```javascript
>   var connection = mysql.createConnection({
>   	host : '127.0.0.1',
>   	user : 'root',
>   	password : '123456',
>   	database : 'xdh'
>   })
>   ```
>
> * 3.开启数据库 ``connection.connect()``
>
> * 4.执行sql
>
>   ```
>   var sql = 'select * from user';
>   connection.query(sql,function(err,result){
>   	if (err) {console.log(err);return;}
>   	
>   	console.log(result);
>   });
>   ```
>
>   

### 9.Express框架

> 基于 Nodejs 平台，快速，开放，极简的 web 开发框架
>
> 它是用于后台Nodejs的框架，与Jquery/Bootstrap/vue.js/这类前端框架是不一样的
>
> Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。
>
> ##### 与原生Nodejs比较
>
> 使用原生Nodejs开发会发现很多问题:
>
> * 呈现静态页面很不方便,需要处理每个HTTP请求，还要考虑304缓存问题
> * 路由处理代码不直观清晰，需要写很多正则表达式和字符串函数
> * 开发者不能集中精力写业务，要考虑很多其他的对象
>
> ##### 响应方法
>
> ```javascript
> res.download()    提示下载文件。
> res.end()         终结响应处理流程。
> res.json()        发送一个JSON格式的响应。
> res.jsonp()       发送一个支持JSONP的JSON格式的响应
> res.redirect()    重定向请求。
> res.render()      渲染视图模板。
> res.send()        发送各种类型的响应。
> res.sendFile()    以八位字节流的形式发送文件。
> res.sendStatus()  设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。
> ```

### 10.中间件

> 中间件就是一种功能的封装方式，就是封装在程序中处理http请求的功能
>
> app.use() 就是一个中间件,与get()/post()..方法不用的是,
> 它的URL不是精确匹配,而是模糊匹配

